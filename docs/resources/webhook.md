---
# generated by https://github.com/hashicorp/terraform-plugin-docs
page_title: "port_webhook Resource - port"
subcategory: ""
description: |-
  Webhook resource
  Webhook resource can be used to create webhooks integrations in Port.
  Example Usage
  
  resource "port_blueprint" "author" {
      title = "Author"
      icon = "User"
      identifier = "author"
      properties = {
        string_props = {
          "name" = {
            type = "string"
            title = "Name"
          }
        }
      }
    }
  
    resource "port_blueprint" "team" {
      title = "Team"
      icon = "Team"
      identifier = "team"
      properties = {
        string_props = {
          "name" = {
            type = "string"
            title = "Team Name"
          }
        }
      }
    }
  
    resource "port_blueprint" "microservice" {
      title = "TF test microservice"
      icon = "Terraform"
      identifier = "microservice"
      properties = {
        string_props = {
          "url" = {
            type = "string"
            title = "URL"
          }
        }
      }
      relations = {
        "author" = {
          title = "Author"
          target = port_blueprint.author.identifier
        }
        "team" = {
          title = "Team"
          target = port_blueprint.team.identifier
        }
      }
    }
  
    resource "port_webhook" "create_pr" {
      identifier = "pr_webhook"
      title      = "Webhook with mixed relations"
      icon       = "Terraform"
      enabled    = true
      
      mappings = [
        {
          blueprint = port_blueprint.microservice.identifier
          operation = { "type" = "create" }
          filter    = ".headers.\"x-github-event\" == \"pull_request\""
          entity = {
            identifier = ".body.pull_request.id | tostring"
            title      = ".body.pull_request.title"
            properties = {
              url = ".body.pull_request.html_url"
            }
            relations = {
              # Complex object relation with search query
              author = jsonencode({
                combinator = "'and'",
                rules = [
                  {
                    property = "'$identifier'"
                    operator = "'='"
                    value    = ".body.pull_request.user.login | tostring"
                  }
                ]
              })
              
              # Simple string relation
              team = ".body.repository.owner.login | tostring"
            }
          }
        }
      ]
      
      depends_on = [
        port_blueprint.microservice,
        port_blueprint.author,
        port_blueprint.team
      ]
    }
  
    # Example with complex identifier using search query
    resource "port_webhook" "complex_identifier" {
      identifier = "complex_identifier_webhook"
      title      = "Webhook with complex identifier"
      icon       = "Terraform"
      enabled    = true
      
      mappings = [
        {
          blueprint = port_blueprint.microservice.identifier
          operation = { "type" = "create" }
          filter    = ".headers.\"x-github-event\" == \"push\""
          entity = {
            # Complex identifier using search query to find entity by ARN
            identifier = jsonencode({
              combinator = "'and'",
              rules = [
                {
                  property = "'arn'"
                  operator = "'='"
                  value    = ".body.resources[0]"
                }
              ]
            })
            title      = ".body.repository.name"
            properties = {
              url = ".body.repository.html_url"
            }
          }
        }
      ]
      
      depends_on = [
        port_blueprint.microservice
      ]
    }
  
  
  Notes
  When using object format for relations, combinator, property and operator fields should be enclosed in single quotes, while value should not have quotes as it's a JQ expression. The single quotes are required because these fields contain literal string values that must be passed as-is to the Port API, whereas value contains a JQ expression that should be evaluated dynamically.The identifier field supports both simple JQ expressions (strings) and complex search query objects. When using search query objects, the structure must include combinator and rules fields, and each rule must have property, operator, and value fields.For all available operators, see the Port comparison operators documentation https://docs.port.io/search-and-query/comparison-operators.
---

# port_webhook (Resource)

# Webhook resource
Webhook resource can be used to create webhooks integrations in Port.

## Example Usage

```hcl
resource "port_blueprint" "author" {
    title = "Author"
    icon = "User"
    identifier = "author"
    properties = {
      string_props = {
        "name" = {
          type = "string"
          title = "Name"
        }
      }
    }
  }

  resource "port_blueprint" "team" {
    title = "Team"
    icon = "Team"
    identifier = "team"
    properties = {
      string_props = {
        "name" = {
          type = "string"
          title = "Team Name"
        }
      }
    }
  }

  resource "port_blueprint" "microservice" {
    title = "TF test microservice"
    icon = "Terraform"
    identifier = "microservice"
    properties = {
      string_props = {
        "url" = {
          type = "string"
          title = "URL"
        }
      }
    }
    relations = {
      "author" = {
        title = "Author"
        target = port_blueprint.author.identifier
      }
      "team" = {
        title = "Team"
        target = port_blueprint.team.identifier
      }
    }
  }

  resource "port_webhook" "create_pr" {
    identifier = "pr_webhook"
    title      = "Webhook with mixed relations"
    icon       = "Terraform"
    enabled    = true
    
    mappings = [
      {
        blueprint = port_blueprint.microservice.identifier
        operation = { "type" = "create" }
        filter    = ".headers.\"x-github-event\" == \"pull_request\""
        entity = {
          identifier = ".body.pull_request.id | tostring"
          title      = ".body.pull_request.title"
          properties = {
            url = ".body.pull_request.html_url"
          }
          relations = {
            # Complex object relation with search query
            author = jsonencode({
              combinator = "'and'",
              rules = [
                {
                  property = "'$identifier'"
                  operator = "'='"
                  value    = ".body.pull_request.user.login | tostring"
                }
              ]
            })
            
            # Simple string relation
            team = ".body.repository.owner.login | tostring"
          }
        }
      }
    ]
    
    depends_on = [
      port_blueprint.microservice,
      port_blueprint.author,
      port_blueprint.team
    ]
  }

  # Example with complex identifier using search query
  resource "port_webhook" "complex_identifier" {
    identifier = "complex_identifier_webhook"
    title      = "Webhook with complex identifier"
    icon       = "Terraform"
    enabled    = true
    
    mappings = [
      {
        blueprint = port_blueprint.microservice.identifier
        operation = { "type" = "create" }
        filter    = ".headers.\"x-github-event\" == \"push\""
        entity = {
          # Complex identifier using search query to find entity by ARN
          identifier = jsonencode({
            combinator = "'and'",
            rules = [
              {
                property = "'arn'"
                operator = "'='"
                value    = ".body.resources[0]"
              }
            ]
          })
          title      = ".body.repository.name"
          properties = {
            url = ".body.repository.html_url"
          }
        }
      }
    ]
    
    depends_on = [
      port_blueprint.microservice
    ]
  }

```

## Notes

- When using object format for relations, `combinator`, `property` and `operator` fields should be enclosed in single quotes, while `value` should not have quotes as it's a JQ expression. The single quotes are required because these fields contain literal string values that must be passed as-is to the Port API, whereas `value` contains a JQ expression that should be evaluated dynamically.
- The `identifier` field supports both simple JQ expressions (strings) and complex search query objects. When using search query objects, the structure must include `combinator` and `rules` fields, and each rule must have `property`, `operator`, and `value` fields.
- For all available operators, see the [Port comparison operators documentation](https://docs.port.io/search-and-query/comparison-operators).



<!-- schema generated by tfplugindocs -->
## Schema

### Optional

- `description` (String) The description of the webhook
- `enabled` (Boolean) Whether the webhook is enabled
- `icon` (String) The icon of the webhook
- `identifier` (String) The identifier of the webhook
- `mappings` (Attributes List) The mappings of the webhook (see [below for nested schema](#nestedatt--mappings))
- `security` (Attributes) The security of the webhook (see [below for nested schema](#nestedatt--security))
- `title` (String) The title of the webhook

### Read-Only

- `created_at` (String) The creation date of the webhook
- `created_by` (String) The creator of the webhook
- `id` (String) The ID of this resource.
- `updated_at` (String) The last update date of the webhook
- `updated_by` (String) The last updater of the webhook
- `url` (String) The url of the webhook
- `webhook_key` (String) The webhook key of the webhook

<a id="nestedatt--mappings"></a>
### Nested Schema for `mappings`

Required:

- `blueprint` (String) The blueprint of the mapping
- `entity` (Attributes) The entity of the mapping (see [below for nested schema](#nestedatt--mappings--entity))

Optional:

- `filter` (String) The filter of the mapping
- `items_to_parse` (String) The items to parser of the mapping
- `operation` (Attributes) The operation of the mapping (see [below for nested schema](#nestedatt--mappings--operation))

<a id="nestedatt--mappings--entity"></a>
### Nested Schema for `mappings.entity`

Required:

- `identifier` (String) The identifier of the entity. Can be either a simple JQ expression (string) or a search query object encoded with jsonencode(). When using search query objects, the structure must include 'combinator' and 'rules' fields, and each rule must have 'property', 'operator', and 'value' fields.

Optional:

- `icon` (String) The icon of the entity
- `properties` (Map of String) The properties of the entity
- `relations` (Map of String) The relations of the entity. Relations can be defined as either simple JQ expressions (strings) or search query objects. When using objects, the rules array must be encoded with jsonencode().
- `team` (String) The team of the entity
- `title` (String) The title of the entity


<a id="nestedatt--mappings--operation"></a>
### Nested Schema for `mappings.operation`

Required:

- `type` (String) The type of the operation

Optional:

- `delete_dependents` (Boolean) Whether to delete dependents entities, only relevant for delete operations



<a id="nestedatt--security"></a>
### Nested Schema for `security`

Optional:

- `request_identifier_path` (String) The request identifier path of the webhook
- `secret` (String) The secret of the webhook
- `signature_algorithm` (String) The signature algorithm of the webhook
- `signature_header_name` (String) The signature header name of the webhook
- `signature_prefix` (String) The signature prefix of the webhook
